name: Bug Report Intake

on:
  repository_dispatch:
    types: [bug-report]
  workflow_dispatch:
    inputs:
      title:
        description: Issue title
        required: true
        type: string
      description:
        description: Issue description
        required: true
        type: string
      type:
        description: Issue type
        required: true
        type: choice
        options:
          - bug
          - feature
          - documentation
          - performance
      email:
        description: Contact email (optional)
        required: false
        type: string
      source:
        description: Source (web/game)
        required: false
        type: choice
        options:
          - web
          - game
      appVersion:
        description: App version (optional)
        required: false
        type: string
      buildId:
        description: Build ID (optional)
        required: false
        type: string
      os:
        description: OS (optional)
        required: false
        type: string
      logs:
        description: Logs (optional)
        required: false
        type: string
      notify:
        description: Request notification (optional)
        required: false
        type: boolean

permissions:
  contents: read
  issues: write

concurrency:
  group: bug-report-${{ github.event.client_payload.dedupeKey || github.event.client_payload.title || github.event.inputs.title }}

jobs:
  create-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Create or Dedupe Issue
        id: create-issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const pd = context.payload.client_payload || {};
            const inp = context.payload.inputs || {};

            function take(k, def='') { return (pd[k] ?? inp[k] ?? def); }
            function clamp(s, n) { s = String(s||''); return s.length>n ? s.slice(0,n) : s; }

            const allowedTypes = ['bug','feature','documentation','performance'];
            let title = clamp(take('title'), 120).trim();
            let description = clamp(take('description'), 10000).trim();
            let type = String(take('type','bug')).toLowerCase();
            if (!allowedTypes.includes(type)) type = 'bug';
            const email = clamp(take('email'), 320);
            const source = String(take('source','web')).toLowerCase();
            const appVersion = clamp(take('appVersion'), 64);
            const buildId = clamp(take('buildId'), 64);
            const os = clamp(take('os'), 128);
            const logs = clamp(take('logs'), 20000);
            const notify = Boolean(take('notify', false));
            const dedupeKey = take('dedupeKey', '');
            const gistUrl = take('gistUrl', '');
            const attachmentName = take('attachmentName', '');
            const attachmentSize = take('attachmentSize', 0);
            const attachmentError = take('attachmentError', '');

            core.info(`Processing ${type} report: "${title}"`);
            core.info(`DedupeKey: ${dedupeKey}`);
            core.info(`Source: ${source}`);

            if (!title || !description) {
              core.setFailed('Missing required fields: title and description');
              return;
            }

            // Check for existing issue by dedupeKey
            if (dedupeKey) {
              const q = `repo:${context.repo.owner}/${context.repo.repo} in:body "${dedupeKey}" state:open`;
              const search = await github.rest.search.issuesAndPullRequests({ q });
              const hit = search.data.items?.[0];
              if (hit) {
                core.info(`Found existing issue #${hit.number} with dedupeKey ${dedupeKey}`);
                core.setOutput('issue_number', hit.number);
                core.setOutput('issue_url', hit.html_url);
                core.setOutput('action', 'duplicate');
                
                // Add comment to existing issue
                let commentBody = `**Duplicate report received**\n\n` +
                  `Source: ${source === 'game' ? 'Game client' : 'Web form'}\n` +
                  `Type: ${type}\n` +
                  (email ? `Email: ${email}\n` : '') +
                  (appVersion ? `App Version: ${appVersion}\n` : '') +
                  (buildId ? `Build ID: ${buildId}\n` : '') +
                  (os ? `OS: ${os}\n` : '') +
                  `\n**Description:**\n${description}\n` +
                  (logs ? `\n**Logs:**\n\`\`\`\n${logs}\n\`\`\`\n` : '');
                
                if (gistUrl) {
                  commentBody += `\n**Attachment:** üìé [${attachmentName}](${gistUrl}) (${Math.round(attachmentSize/1024)} KB)\n`;
                } else if (attachmentError) {
                  commentBody += `\n**Attachment:** ‚ö†Ô∏è ${attachmentError}\n`;
                }
                
                commentBody += `\n---\n*DedupeKey: ${dedupeKey}*`;
                  
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: hit.number,
                  body: commentBody
                });
                return;
              }
            }

            // Create required labels if they don't exist
            const labelMap = {
              bug: ['type: bug', 'priority: medium'],
              feature: ['type: enhancement', 'priority: medium'],
              documentation: ['type: documentation', 'priority: medium'],
              performance: ['type: performance', 'priority: medium']
            };
            const wantedLabels = labelMap[type] || ['type: bug', 'priority: medium'];
            
            const existingLabels = await github.paginate(github.rest.issues.listLabelsForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            const existingNames = new Set(existingLabels.map(l => l.name));
            
            for (const labelName of wantedLabels) {
              if (!existingNames.has(labelName)) {
                try {
                  const color = labelName.startsWith('type:') ? 'B60205' : 
                               labelName.startsWith('priority:') ? 'FBCA04' : 'CCCCCC';
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: labelName,
                    color: color,
                    description: labelName.startsWith('type:') ? `Issue type: ${labelName.split(': ')[1]}` :
                                labelName.startsWith('priority:') ? `Priority level: ${labelName.split(': ')[1]}` : ''
                  });
                  core.info(`Created label: ${labelName}`);
                } catch (error) {
                  core.warning(`Failed to create label ${labelName}: ${error.message}`);
                }
              }
            }

            // Create issue body
            const titlePrefix = source === 'game' ? '[game] ' : '[web] ';
            let body = `## Description\n${description}\n\n`;
            body += `## Issue Type\n${type}\n\n`;
            body += `## Submitted From\n${source === 'game' ? 'Game client' : 'Web form'}\n\n`;
            body += `## Contact Information\n${email ? `Email: ${email}` : 'No contact email provided'}\n\n`;
            body += `## Environment\n- App Version: ${appVersion || 'n/a'}\n- Build ID: ${buildId || 'n/a'}\n- OS: ${os || 'n/a'}\n\n`;
            
            if (logs) {
              body += `## Logs\n<details><summary>Show logs</summary>\n\n\`\`\`\n${logs}\n\`\`\`\n\n</details>\n\n`;
            }
            
            if (gistUrl) {
              body += `## Attachment\nüìé **${attachmentName}** (${Math.round(attachmentSize/1024)} KB)\n\n`;
              body += `[View attachment on Gist](${gistUrl})\n\n`;
            } else if (attachmentError) {
              body += `## Attachment\n‚ö†Ô∏è ${attachmentError}\n\n`;
            }
            
            body += `---\n*This issue was automatically created from a ${source} submission.*\n\n`;
            if (dedupeKey) body += `<!-- dedupe:${dedupeKey} -->\n`;
            body += `\n### Next Steps\n- [ ] Reproduce the issue\n- [ ] Assign appropriate labels\n- [ ] Set milestone if applicable\n- [ ] Link to related issues if any`;

            // Create the issue
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: titlePrefix + title,
              body,
              labels: wantedLabels
            });

            core.info(`Created issue #${issue.data.number}: ${issue.data.html_url}`);
            core.setOutput('issue_number', issue.data.number);
            core.setOutput('issue_url', issue.data.html_url);
            core.setOutput('action', 'created');

            // Add high priority label for critical issues
            const descLower = description.toLowerCase();
            if (descLower.includes('crash') || descLower.includes('critical') || descLower.includes('urgent')) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.data.number,
                  labels: ['priority: high', 'needs: immediate-attention']
                });
                core.info('Added high priority labels for critical issue');
              } catch (error) {
                core.warning(`Failed to add high priority labels: ${error.message}`);
              }
            }

      - name: Assign Maintainers
        if: steps.create-issue.outputs.action == 'created'
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const issueNumber = ${{ steps.create-issue.outputs.issue_number }};
            const maintainers = ['PipFoweraker']; // Add other maintainers as needed
            
            try {
              // Assign maintainers to the issue
              await github.rest.issues.addAssignees({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                assignees: maintainers
              });
              
              core.info(`Assigned maintainers to issue #${issueNumber}: ${maintainers.join(', ')}`);
            } catch (error) {
              core.warning(`Failed to assign maintainers: ${error.message}`);
              
              // Fallback: mention maintainers in a comment
              const mentionComment = `@${maintainers.join(' @')} - New ${context.payload.client_payload?.type || 'bug'} report needs attention.`;
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: mentionComment
              });
              
              core.info(`Mentioned maintainers in comment: ${maintainers.join(', ')}`);
            }

      - name: Generate Run Log Summary
        run: |
          echo "## Bug Report Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Action**: ${{ steps.create-issue.outputs.action }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Issue Number**: #${{ steps.create-issue.outputs.issue_number }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Issue URL**: ${{ steps.create-issue.outputs.issue_url }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Type**: ${{ github.event.client_payload.type || github.event.inputs.type || 'bug' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Source**: ${{ github.event.client_payload.source || github.event.inputs.source || 'web' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **DedupeKey**: ${{ github.event.client_payload.dedupeKey || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Workflow Run**: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY

  notify:
    needs: create-issue
    runs-on: ubuntu-latest
    if: ${{ (github.event.client_payload && github.event.client_payload.notify == true) || (github.event.inputs && github.event.inputs.notify == 'true') }}
    steps:
      - name: Send Notification
        run: |
          echo "üêõ New bug report received!"
          echo "üìã Issue: #${{ needs.create-issue.outputs.issue_number }}"
          echo "üîó URL: ${{ needs.create-issue.outputs.issue_url }}"
          echo "üìù Title: ${{ github.event.client_payload.title || github.event.inputs.title }}"
          echo "üè∑Ô∏è Type: ${{ github.event.client_payload.type || github.event.inputs.type || 'bug' }}"
